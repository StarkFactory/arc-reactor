package com.arc.reactor.promptlab

import com.arc.reactor.promptlab.model.EvaluationConfig
import com.arc.reactor.promptlab.model.EvaluationResult
import com.arc.reactor.promptlab.model.Experiment
import com.arc.reactor.promptlab.model.ExperimentReport
import com.arc.reactor.promptlab.model.ExperimentStatus
import com.arc.reactor.promptlab.model.TestQuery
import com.arc.reactor.promptlab.model.TokenUsageSummary
import com.arc.reactor.promptlab.model.Trial
import com.fasterxml.jackson.databind.DeserializationFeature
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule
import com.fasterxml.jackson.module.kotlin.jacksonObjectMapper
import com.fasterxml.jackson.module.kotlin.readValue
import mu.KotlinLogging
import org.springframework.dao.DuplicateKeyException
import org.springframework.jdbc.core.JdbcTemplate
import org.springframework.transaction.support.TransactionTemplate
import java.sql.ResultSet
import java.sql.Timestamp

private val logger = KotlinLogging.logger {}

/**
 * JDBC-based Experiment Store for persistent experiment storage.
 *
 * Stores experiments in the `experiments` table, trials in `trials`,
 * and reports in `experiment_reports` — see Flyway migration V25.
 * Complex fields are stored as JSON TEXT columns.
 *
 * Uses UPDATE-then-INSERT pattern for database-agnostic upsert (H2 + PostgreSQL).
 * Cascade delete is wrapped in a transaction for atomicity.
 */
class JdbcExperimentStore(
    private val jdbcTemplate: JdbcTemplate,
    private val transactionTemplate: TransactionTemplate
) : ExperimentStore {

    override fun save(experiment: Experiment): Experiment {
        val updated = jdbcTemplate.update(
            """UPDATE experiments SET
                name = ?, description = ?, template_id = ?, baseline_version_id = ?,
                candidate_version_ids = ?, test_queries = ?, evaluation_config = ?,
                model = ?, judge_model = ?, temperature = ?, repetitions = ?,
                auto_generated = ?, status = ?, created_by = ?, created_at = ?,
                started_at = ?, completed_at = ?, error_message = ?
               WHERE id = ?""",
            experiment.name,
            experiment.description,
            experiment.templateId,
            experiment.baselineVersionId,
            objectMapper.writeValueAsString(experiment.candidateVersionIds),
            objectMapper.writeValueAsString(experiment.testQueries),
            objectMapper.writeValueAsString(experiment.evaluationConfig),
            experiment.model,
            experiment.judgeModel,
            experiment.temperature,
            experiment.repetitions,
            experiment.autoGenerated,
            experiment.status.name,
            experiment.createdBy,
            Timestamp.from(experiment.createdAt),
            experiment.startedAt?.let { Timestamp.from(it) },
            experiment.completedAt?.let { Timestamp.from(it) },
            experiment.errorMessage,
            experiment.id
        )
        if (updated == 0) {
            jdbcTemplate.update(
                """INSERT INTO experiments (
                    id, name, description, template_id, baseline_version_id,
                    candidate_version_ids, test_queries, evaluation_config,
                    model, judge_model, temperature, repetitions, auto_generated,
                    status, created_by, created_at, started_at, completed_at, error_message
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)""",
                experiment.id,
                experiment.name,
                experiment.description,
                experiment.templateId,
                experiment.baselineVersionId,
                objectMapper.writeValueAsString(experiment.candidateVersionIds),
                objectMapper.writeValueAsString(experiment.testQueries),
                objectMapper.writeValueAsString(experiment.evaluationConfig),
                experiment.model,
                experiment.judgeModel,
                experiment.temperature,
                experiment.repetitions,
                experiment.autoGenerated,
                experiment.status.name,
                experiment.createdBy,
                Timestamp.from(experiment.createdAt),
                experiment.startedAt?.let { Timestamp.from(it) },
                experiment.completedAt?.let { Timestamp.from(it) },
                experiment.errorMessage
            )
        }
        return experiment
    }

    override fun get(id: String): Experiment? {
        val results = jdbcTemplate.query(
            "SELECT * FROM experiments WHERE id = ?",
            EXPERIMENT_ROW_MAPPER,
            id
        )
        return results.firstOrNull()
    }

    override fun list(status: ExperimentStatus?, templateId: String?): List<Experiment> {
        val conditions = mutableListOf<String>()
        val params = mutableListOf<Any>()

        if (status != null) {
            conditions.add("status = ?")
            params.add(status.name)
        }
        if (templateId != null) {
            conditions.add("template_id = ?")
            params.add(templateId)
        }

        val where = if (conditions.isEmpty()) "" else " WHERE ${conditions.joinToString(" AND ")}"
        val sql = "SELECT * FROM experiments$where ORDER BY created_at DESC"

        return jdbcTemplate.query(sql, EXPERIMENT_ROW_MAPPER, *params.toTypedArray())
    }

    override fun delete(id: String) {
        transactionTemplate.execute {
            jdbcTemplate.update("DELETE FROM experiment_reports WHERE experiment_id = ?", id)
            jdbcTemplate.update("DELETE FROM trials WHERE experiment_id = ?", id)
            jdbcTemplate.update("DELETE FROM experiments WHERE id = ?", id)
        }
    }

    override fun saveTrials(experimentId: String, trials: List<Trial>) {
        for (trial in trials) {
            try {
                jdbcTemplate.update(
                    """INSERT INTO trials (
                        id, experiment_id, prompt_version_id, prompt_version_number,
                        test_query, repetition_index, response, success, error_message,
                        tools_used, token_usage, duration_ms, evaluations, executed_at
                    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)""",
                    trial.id,
                    trial.experimentId,
                    trial.promptVersionId,
                    trial.promptVersionNumber,
                    objectMapper.writeValueAsString(trial.testQuery),
                    trial.repetitionIndex,
                    trial.response,
                    trial.success,
                    trial.errorMessage,
                    objectMapper.writeValueAsString(trial.toolsUsed),
                    trial.tokenUsage?.let { objectMapper.writeValueAsString(it) },
                    trial.durationMs,
                    objectMapper.writeValueAsString(trial.evaluations),
                    Timestamp.from(trial.executedAt)
                )
            } catch (e: DuplicateKeyException) {
                logger.debug { "Trial ${trial.id} already saved — idempotent skip on retry" }
            }
        }
    }

    override fun getTrials(experimentId: String): List<Trial> {
        return jdbcTemplate.query(
            "SELECT * FROM trials WHERE experiment_id = ? ORDER BY executed_at",
            TRIAL_ROW_MAPPER,
            experimentId
        )
    }

    override fun saveReport(experimentId: String, report: ExperimentReport) {
        val reportJson = objectMapper.writeValueAsString(report)
        val timestamp = Timestamp.from(report.generatedAt)
        val updated = jdbcTemplate.update(
            "UPDATE experiment_reports SET report_data = ?, created_at = ? WHERE experiment_id = ?",
            reportJson, timestamp, experimentId
        )
        if (updated == 0) {
            jdbcTemplate.update(
                "INSERT INTO experiment_reports (experiment_id, report_data, created_at) VALUES (?, ?, ?)",
                experimentId, reportJson, timestamp
            )
        }
    }

    override fun getReport(experimentId: String): ExperimentReport? {
        val results = jdbcTemplate.query(
            "SELECT * FROM experiment_reports WHERE experiment_id = ?",
            { rs, _ -> parseJson<ExperimentReport>(rs.getString("report_data")) },
            experimentId
        )
        return results.firstOrNull()
    }

    companion object {
        private val objectMapper = jacksonObjectMapper().apply {
            registerModule(JavaTimeModule())
            configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false)
        }

        private inline fun <reified T> parseJson(json: String?): T? {
            if (json == null) return null
            return try {
                objectMapper.readValue<T>(json)
            } catch (e: Exception) {
                logger.warn { "Failed to parse JSON: ${e.message}" }
                null
            }
        }

        private val EXPERIMENT_ROW_MAPPER = { rs: ResultSet, _: Int ->
            Experiment(
                id = rs.getString("id"),
                name = rs.getString("name"),
                description = rs.getString("description").orEmpty(),
                templateId = rs.getString("template_id"),
                baselineVersionId = rs.getString("baseline_version_id"),
                candidateVersionIds = parseJson<List<String>>(rs.getString("candidate_version_ids")) ?: emptyList(),
                testQueries = parseJson<List<TestQuery>>(rs.getString("test_queries")) ?: emptyList(),
                evaluationConfig = parseJson<EvaluationConfig>(rs.getString("evaluation_config")) ?: EvaluationConfig(),
                model = rs.getString("model"),
                judgeModel = rs.getString("judge_model"),
                temperature = rs.getDouble("temperature"),
                repetitions = rs.getInt("repetitions"),
                autoGenerated = rs.getBoolean("auto_generated"),
                status = ExperimentStatus.valueOf(rs.getString("status")),
                createdBy = rs.getString("created_by"),
                createdAt = rs.getTimestamp("created_at").toInstant(),
                startedAt = rs.getTimestamp("started_at")?.toInstant(),
                completedAt = rs.getTimestamp("completed_at")?.toInstant(),
                errorMessage = rs.getString("error_message")
            )
        }

        private val TRIAL_ROW_MAPPER = { rs: ResultSet, _: Int ->
            Trial(
                id = rs.getString("id"),
                experimentId = rs.getString("experiment_id"),
                promptVersionId = rs.getString("prompt_version_id"),
                promptVersionNumber = rs.getInt("prompt_version_number"),
                testQuery = parseJson<TestQuery>(rs.getString("test_query")) ?: TestQuery(query = ""),
                repetitionIndex = rs.getInt("repetition_index"),
                response = rs.getString("response"),
                success = rs.getBoolean("success"),
                errorMessage = rs.getString("error_message"),
                toolsUsed = parseJson<List<String>>(rs.getString("tools_used")) ?: emptyList(),
                tokenUsage = parseJson<TokenUsageSummary>(rs.getString("token_usage")),
                durationMs = rs.getLong("duration_ms"),
                evaluations = parseJson<List<EvaluationResult>>(rs.getString("evaluations")) ?: emptyList(),
                executedAt = rs.getTimestamp("executed_at").toInstant()
            )
        }
    }
}
