package com.arc.reactor.promptlab.analysis

import com.arc.reactor.config.ChatModelProvider
import com.arc.reactor.prompt.PromptTemplateStore
import com.arc.reactor.promptlab.model.FeedbackAnalysis
import com.fasterxml.jackson.module.kotlin.jacksonObjectMapper
import mu.KotlinLogging
import kotlin.coroutines.cancellation.CancellationException

private val logger = KotlinLogging.logger {}

/**
 * Generates candidate prompt improvements based on feedback analysis.
 *
 * Uses LLM to produce diverse prompt variations that address
 * identified weaknesses while preserving existing strengths.
 */
class PromptCandidateGenerator(
    private val chatModelProvider: ChatModelProvider,
    private val promptTemplateStore: PromptTemplateStore
) {

    private val mapper = jacksonObjectMapper()

    /**
     * Generate candidate prompt versions addressing identified weaknesses.
     *
     * @param templateId the prompt template to improve
     * @param analysis feedback analysis with identified weaknesses
     * @param candidateCount number of candidate prompts to generate
     * @return list of created PromptVersion IDs
     * @throws IllegalStateException if no active version exists
     */
    suspend fun generate(
        templateId: String,
        analysis: FeedbackAnalysis,
        candidateCount: Int = 3
    ): List<String> {
        val activeVersion = promptTemplateStore.getActiveVersion(templateId)
            ?: throw IllegalStateException("No active version for template=$templateId")
        val metaPrompt = buildMetaPrompt(activeVersion.content, analysis, candidateCount)
        val candidates = generateCandidates(metaPrompt, candidateCount)
        val categories = analysis.weaknesses.joinToString(", ") { it.category }
        return candidates.mapNotNull { candidate ->
            val changeLog = "Auto-generated by Prompt Lab: addresses $categories"
            val version = promptTemplateStore.createVersion(templateId, candidate, changeLog)
            version?.id
        }.also { ids ->
            logger.info { "Generated ${ids.size} candidate versions for template=$templateId" }
        }
    }

    private suspend fun generateCandidates(prompt: String, count: Int): List<String> {
        val response = callLlm(prompt)
        return parseCandidateResponse(response, count)
    }

    private fun buildMetaPrompt(
        currentPrompt: String,
        analysis: FeedbackAnalysis,
        candidateCount: Int
    ): String {
        val weaknessList = analysis.weaknesses.joinToString("\n") { w ->
            "- ${w.category}: ${w.description} (frequency: ${w.frequency}, examples: ${w.exampleQueries})"
        }
        return """You are a prompt engineering expert. Improve the following system prompt.
            |
            |Current system prompt:
            |---
            |$currentPrompt
            |---
            |
            |Identified weaknesses:
            |$weaknessList
            |
            |Instructions:
            |1. Improve the system prompt to address each weakness while preserving existing strengths
            |2. Generate $candidateCount distinct improvement strategies
            |3. Each candidate should be a complete, standalone system prompt
            |
            |Respond with a JSON array of $candidateCount prompt strings only:
            |["improved prompt 1", "improved prompt 2", ...]""".trimMargin()
    }

    private suspend fun callLlm(prompt: String): String {
        try {
            val client = chatModelProvider.getChatClient(null)
            return client.prompt().user(prompt).call().content().orEmpty()
        } catch (e: CancellationException) {
            throw e
        } catch (e: Exception) {
            logger.error(e) { "LLM call failed during candidate generation" }
            return ""
        }
    }

    private fun parseCandidateResponse(
        response: String,
        expectedCount: Int
    ): List<String> {
        if (response.isBlank()) return emptyList()
        return try {
            val cleaned = response
                .replace(CODE_FENCE_REGEX, "").trim()
            val tree = mapper.readTree(cleaned)
            if (!tree.isArray) return emptyList()
            tree.map { it.asText() }
                .filter { it.isNotBlank() }
                .take(expectedCount)
        } catch (e: Exception) {
            logger.warn(e) { "Failed to parse LLM candidate response" }
            emptyList()
        }
    }

    companion object {
        private val CODE_FENCE_REGEX = Regex("```json\\s*|```\\s*")
    }
}
